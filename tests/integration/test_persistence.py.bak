# tests/integration/test_persistence.py
import pytest
import os
import uuid
import time
from datetime import datetime, timezone
from aura_v2.infrastructure.persistence.mongo import MongoTrackRepository
from aura_v2.domain.entities import Track, TrackState, Position3D, Velocity3D, Confidence, TrackStatus, ThreatLevel

# --- Test Fixtures ---

@pytest.fixture(scope="function")
async def mongo_repository():
    """
    Provides a clean and isolated MongoDB repository for each test function.
    Connects to a test database, yields the repository, and then drops
    the database during teardown to ensure test isolation.
    """
    mongo_uri = os.getenv("MONGO_URI_TEST", "mongodb://localhost:27017")
    db_name = f"aura_test_db_{uuid.uuid4().hex}"
    
    os.environ["MONGO_URI"] = mongo_uri
    os.environ["MONGO_DB"] = db_name
    
    repo = MongoTrackRepository()
    
    yield repo
    
    await repo._collection.database.client.drop_database(db_name)
    del os.environ["MONGO_URI"]
    del os.environ["MONGO_DB"]

@pytest.fixture
def sample_track() -> Track:
    """Provides a sample Track domain object for use in tests."""
    return Track(
        id=str(uuid.uuid4()),
        state=TrackState(
            position=Position3D(x=10.5, y=20.0, z=5.1),
            velocity=Velocity3D(vx=1.2, vy=0.8, vz=0.0),
        ),
        status=TrackStatus.ACTIVE,
        confidence=Confidence(0.95),
        threat_level=ThreatLevel.MEDIUM,
        created_at=datetime.now(timezone.utc),
        updated_at=datetime.now(timezone.utc),
        hits=5,
        missed=1,
    )

# --- Integration Test Cases ---

@pytest.mark.asyncio
async def test_full_crud_lifecycle(mongo_repository: MongoTrackRepository, sample_track: Track):
    """
    Validates the fundamental correctness of all repository methods (save, get, list, delete)
    in a sequential workflow, confirming that serialization and deserialization are lossless.
    """
    await mongo_repository.save(sample_track)
    retrieved_track = await mongo_repository.get(sample_track.id)
    
    assert retrieved_track is not None
    assert retrieved_track == sample_track

    all_tracks = await mongo_repository.list()
    assert len(all_tracks) == 1
    assert all_tracks[0] == sample_track

    await mongo_repository.delete(sample_track.id)
    deleted_track = await mongo_repository.get(sample_track.id)
    assert deleted_track is None

@pytest.mark.asyncio
async def test_state_recovery_across_instances(mongo_repository: MongoTrackRepository, sample_track: Track):
    """
    Validates that state is maintained independently of the application's lifecycle.
    """
    repo_A = mongo_repository
    await repo_A.save(sample_track)
    
    repo_B = MongoTrackRepository()

    retrieved_track = await repo_B.get(sample_track.id)
    
    assert retrieved_track is not None
    assert retrieved_track == sample_track
    
    await repo_B._collection.database.client.close()

@pytest.mark.asyncio
async def test_save_performance(mongo_repository: MongoTrackRepository):
    """
    Benchmarks the latency of the save operation to ensure it meets the performance
    budget of <= 5ms on average, as required for the real-time system.
    """
    latencies = []
    num_iterations = 1000

    for i in range(num_iterations):
        track = Track(
            id=f"perf_track_{i}",
            state=TrackState(
                position=Position3D(x=float(i), y=2.0, z=3.0),
                velocity=Velocity3D(vx=0.1, vy=0.2, vz=0.3)
            )
        )
        
        start_time = time.perf_counter()
        await mongo_repository.save(track)
        end_time = time.perf_counter()
        
        latencies.append(end_time - start_time)

    average_latency_sec = sum(latencies) / num_iterations
    
    print(f"\nAverage save latency: {average_latency_sec * 1000:.4f} ms")
    
    assert average_latency_sec <= 0.005