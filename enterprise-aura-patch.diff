diff --git a/aura_v2/infrastructure/tracking/modern_tracker.py b/aura_v2/infrastructure/tracking/modern_tracker.py
--- a/aura_v2/infrastructure/tracking/modern_tracker.py
+++ b/aura_v2/infrastructure/tracking/modern_tracker.py
@@
-from dataclasses import dataclass
+from dataclasses import dataclass, replace
@@
     def predict_track(self, track: Track, timestamp: datetime) -> None:
         kf = self.kalman_filters[track.id]
         dt = (timestamp - track.updated_at).total_seconds()
         if dt <= 0:
             return
@@
-        kf.predict()
-        track.state.position.x = kf.x[0, 0]
-        track.state.position.y = kf.x[1, 0]
-        track.state.position.z = kf.x[2, 0]
-        track.state.velocity.vx = kf.x[3, 0]
-        track.state.velocity.vy = kf.x[4, 0]
-        track.state.velocity.vz = kf.x[5, 0]
-        track.updated_at = timestamp
+        kf.predict()
+        # Create new Position3D and Velocity3D instances since TrackState is frozen
+        pos = replace(
+            track.state.position,
+            x=float(kf.x[0, 0]),
+            y=float(kf.x[1, 0]),
+            z=float(kf.x[2, 0]),
+        )
+        vel = track.state.velocity or Velocity3D(0.0, 0.0, 0.0)
+        vel = replace(
+            vel,
+            vx=float(kf.x[3, 0]),
+            vy=float(kf.x[4, 0]),
+            vz=float(kf.x[5, 0]),
+        )
+        track.state = replace(track.state, position=pos, velocity=vel)
+        track.updated_at = timestamp
@@
-    def _update_track(self, track: Track, detection: Detection, score: float, timestamp: datetime):
-        kf = self.kalman_filters[track.id]
-        kf.update(np.array([detection.position.x, detection.position.y, detection.position.z]))
-        track.state.position.x = kf.x[0, 0]
-        track.state.position.y = kf.x[1, 0]
-        track.state.position.z = kf.x[2, 0]
-        track.state.velocity.vx = kf.x[3, 0]
-        track.state.velocity.vy = kf.x[4, 0]
-        track.state.velocity.vz = kf.x[5, 0]
-        track.updated_at = timestamp
+    def _update_track(self, track: Track, detection: Detection, score: float, timestamp: datetime) -> None:
+        kf = self.kalman_filters[track.id]
+        kf.update(np.array([detection.position.x, detection.position.y, detection.position.z]))
+        # Rebuild position and velocity instances to respect frozen dataclasses
+        pos = replace(
+            track.state.position,
+            x=float(kf.x[0, 0]),
+            y=float(kf.x[1, 0]),
+            z=float(kf.x[2, 0]),
+        )
+        vel = track.state.velocity or Velocity3D(0.0, 0.0, 0.0)
+        vel = replace(
+            vel,
+            vx=float(kf.x[3, 0]),
+            vy=float(kf.x[4, 0]),
+            vz=float(kf.x[5, 0]),
+        )
+        track.state = replace(track.state, position=pos, velocity=vel)
+        track.updated_at = timestamp
@@
     def _init_kf(self, track: Track) -> None:
@@
-        x0 = np.array([
-            track.state.position.x,
-            track.state.position.y,
-            track.state.position.z,
-            track.state.velocity.vx if track.state.velocity else 0.0,
-            track.state.velocity.vy if track.state.velocity else 0.0,
-            track.state.velocity.vz if track.state.velocity else 0.0,
-        ], dtype=float).reshape(6, 1)
+        x0 = np.array([
+            track.state.position.x,
+            track.state.position.y,
+            track.state.position.z,
+            (track.state.velocity.vx if track.state.velocity else 0.0),
+            (track.state.velocity.vy if track.state.velocity else 0.0),
+            (track.state.velocity.vz if track.state.velocity else 0.0),
+        ], dtype=float).reshape(6, 1)
@@
     def _new_track_from_detection(self, detection: Detection, now: datetime) -> Track:
@@
-        state = TrackState(position=detection.position, velocity=None)
+        # Provide a default velocity so Kalman filter initialization always has a velocity state
+        state = TrackState(position=detection.position, velocity=Velocity3D(0.0, 0.0, 0.0))
@@
     async def update(self, detections: list[Detection], timestamp: datetime) -> TrackingResult:
@@
-        for track in unmatched_tracks:
-            self.predict_track(track, timestamp)
-        return TrackingResult(
-            active_tracks=list(self.tracks.values()),
-            new_tracks=new_tracks,
-            deleted_tracks=deleted_tracks,
-        )
+        for track in unmatched_tracks:
+            self.predict_track(track, timestamp)
+        # Keep all unmatched tracks active; deletion is handled elsewhere
+        return TrackingResult(
+            active_tracks=list(self.tracks.values()),
+            new_tracks=new_tracks,
+            deleted_tracks=deleted_tracks,
+        )
diff --git a/aura_v2/application/use_cases/process_detections.py b/aura_v2/application/use_cases/process_detections.py
--- a/aura_v2/application/use_cases/process_detections.py
+++ b/aura_v2/application/use_cases/process_detections.py
@@ class ProcessDetectionsUseCase:
-        self.track_manager.tracks = {t.id: t for t in active_tracks}
-        # Also sync the Kalman filters to prevent errors on subsequent updates.
-        self.track_manager.kalman_filters = {
-            t.id: self.track_manager.kalman_filters[t.id]
-            for t in active_tracks if t.id in self.track_manager.kalman_filters
-        }
+        self.track_manager.tracks = {t.id: t for t in active_tracks}
+        # Ensure each loaded track has a Kalman filter; create one if missing
+        for t in active_tracks:
+            if t.id not in self.track_manager.kalman_filters:
+                self.track_manager._init_kf(t)
diff --git a/aura_v2/domain/entities.py b/aura_v2/domain/entities.py
--- a/aura_v2/domain/entities.py
+++ b/aura_v2/domain/entities.py
@@
-@dataclass(frozen=True)
-class TrackState:
-    position: Position3D
-    velocity: Optional[Velocity3D] = None
+@dataclass(frozen=True)
+class TrackState:
+    position: Position3D
+    velocity: Optional[Velocity3D] = None  # remains optional for schema but will be populated at runtime
